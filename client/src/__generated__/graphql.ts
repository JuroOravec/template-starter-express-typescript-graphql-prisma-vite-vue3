import gql from 'graphql-tag';
import * as VueApolloComposable from '@vue/apollo-composable';
import type * as VueCompositionApi from 'vue';
import type { FieldPolicy, FieldReadFunction, TypePolicies, TypePolicy } from '@apollo/client/cache';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };

/* eslint-disable */
/* This file is autogenerated, see codegen.ts */
export type ReactiveFunction<TParam> = () => TParam;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string | number; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  AccountNumber: { input: any; output: any; }
  BigInt: { input: any; output: any; }
  Byte: { input: any; output: any; }
  CountryCode: { input: string; output: string; }
  Cuid: { input: any; output: any; }
  Currency: { input: string; output: string; }
  DID: { input: any; output: any; }
  Date: { input: any; output: any; }
  DateTime: { input: string; output: string; }
  DateTimeISO: { input: any; output: any; }
  DeweyDecimal: { input: any; output: any; }
  Duration: { input: any; output: any; }
  EmailAddress: { input: string; output: string; }
  GUID: { input: any; output: any; }
  HSL: { input: any; output: any; }
  HSLA: { input: any; output: any; }
  HexColorCode: { input: any; output: any; }
  Hexadecimal: { input: any; output: any; }
  IBAN: { input: any; output: any; }
  IP: { input: any; output: any; }
  IPCPatent: { input: any; output: any; }
  IPv4: { input: any; output: any; }
  IPv6: { input: any; output: any; }
  ISBN: { input: any; output: any; }
  ISO8601Duration: { input: any; output: any; }
  JSON: { input: any; output: any; }
  JSONObject: { input: any; output: any; }
  JWT: { input: any; output: any; }
  LCCSubclass: { input: any; output: any; }
  Latitude: { input: any; output: any; }
  LocalDate: { input: any; output: any; }
  LocalDateTime: { input: any; output: any; }
  LocalEndTime: { input: any; output: any; }
  LocalTime: { input: any; output: any; }
  Locale: { input: any; output: any; }
  Long: { input: any; output: any; }
  Longitude: { input: any; output: any; }
  MAC: { input: any; output: any; }
  NegativeFloat: { input: any; output: any; }
  NegativeInt: { input: any; output: any; }
  NonEmptyString: { input: any; output: any; }
  NonNegativeFloat: { input: number; output: number; }
  NonNegativeInt: { input: number; output: number; }
  NonPositiveFloat: { input: any; output: any; }
  NonPositiveInt: { input: any; output: any; }
  ObjectID: { input: any; output: any; }
  PhoneNumber: { input: string; output: string; }
  Port: { input: any; output: any; }
  PositiveFloat: { input: any; output: any; }
  PositiveInt: { input: any; output: any; }
  PostalCode: { input: any; output: any; }
  RGB: { input: any; output: any; }
  RGBA: { input: any; output: any; }
  RoutingNumber: { input: any; output: any; }
  SafeInt: { input: any; output: any; }
  SemVer: { input: any; output: any; }
  Time: { input: any; output: any; }
  TimeZone: { input: any; output: any; }
  Timestamp: { input: any; output: any; }
  URL: { input: string; output: string; }
  USCurrency: { input: any; output: any; }
  UUID: { input: any; output: any; }
  UnsignedFloat: { input: any; output: any; }
  UnsignedInt: { input: any; output: any; }
  UtcOffset: { input: any; output: any; }
  Void: { input: any; output: any; }
};

export type GqlAdminMutation = {
  __typename?: 'AdminMutation';
  hello?: Maybe<Scalars['String']['output']>;
};

export type GqlAdminQuery = {
  __typename?: 'AdminQuery';
  hello?: Maybe<Scalars['String']['output']>;
};

/**
 * Interface for cursor pagination connection.
 *
 * This interface follows the GraphQL Cursor Connections Specification. See https://relay.dev/graphql/connections.htm#sec-Connection-Types
 */
export type GqlConnection = {
  edges: Array<GqlEdge>;
  pageInfo: GqlPageInfo;
};

/**
 * Partial interface for cursor pagination edge.
 *
 * The 'node' field is intentionally omitted as that differs between implementations.
 *
 * This interface follows the GraphQL Cursor Connections Specification. See https://relay.dev/graphql/connections.htm#sec-Edge-Types
 */
export type GqlEdge = {
  cursor: Scalars['String']['output'];
};

export type GqlMeMutation = {
  __typename?: 'MeMutation';
  hello?: Maybe<Scalars['String']['output']>;
  updateUserSettings?: Maybe<GqlUserSettings>;
};


export type GqlMeMutationupdateUserSettingsArgs = {
  userSettings: GqlUserSettingsUpdateInput;
};

export type GqlMeQuery = {
  __typename?: 'MeQuery';
  hello?: Maybe<Scalars['String']['output']>;
  user?: Maybe<GqlUser>;
};

export type GqlMutation = {
  __typename?: 'Mutation';
  /** Mutations available to authenticated admin user. */
  admin?: Maybe<GqlAdminMutation>;
  hello?: Maybe<Scalars['String']['output']>;
  /** Mutations available to authenticated user. */
  me?: Maybe<GqlMeMutation>;
};

export type GqlPageInfo = {
  __typename?: 'PageInfo';
  /** Cursor corresponding to the last node in edges. */
  endCursor?: Maybe<Scalars['String']['output']>;
  /** Whether more edges exist after to the defined set. */
  hasNextPage: Scalars['Boolean']['output'];
  /** Whether more edges exist prior to the defined set. */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** Cursor corresponding to the first node in edges. */
  startCursor?: Maybe<Scalars['String']['output']>;
  totalCount: Scalars['NonNegativeInt']['output'];
};

export type GqlPaginateDirectiveDefaults = {
  itemsPerPage?: InputMaybe<Scalars['NonNegativeInt']['input']>;
};

export type GqlQuery = {
  __typename?: 'Query';
  /** Queries available to authenticated admin user. */
  admin?: Maybe<GqlAdminQuery>;
  hello?: Maybe<Scalars['String']['output']>;
  /** Queries available to authenticated user. */
  me?: Maybe<GqlMeQuery>;
};

export type GqlUser = {
  __typename?: 'User';
  email: Scalars['EmailAddress']['output'];
  firstName?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  userId: Scalars['String']['output'];
  userRoles: Array<GqlUserRoleType>;
  userSettings: GqlUserSettings;
};

export enum GqlUserRoleType {
  ADMIN = 'ADMIN'
}

export type GqlUserSettings = {
  __typename?: 'UserSettings';
  testVal: Scalars['Int']['output'];
  userId: Scalars['String']['output'];
};

export type GqlUserSettingsUpdateInput = {
  testVal?: InputMaybe<Scalars['Int']['input']>;
};

export type GqlMeUserFragment = { __typename?: 'User', userId: string, firstName?: string | null, lastName?: string | null, userRoles: Array<GqlUserRoleType> };

export type GqlgetMeUserQueryVariables = Exact<{ [key: string]: never; }>;


export type GqlgetMeUserQuery = { __typename?: 'Query', me?: { __typename?: 'MeQuery', user?: { __typename?: 'User', userId: string, firstName?: string | null, lastName?: string | null, userRoles: Array<GqlUserRoleType> } | null } | null };

export type GqlMeUserSettingsFragment = { __typename?: 'UserSettings', userId: string, testVal: number };

export type GqlgetMeUserSettingsQueryVariables = Exact<{ [key: string]: never; }>;


export type GqlgetMeUserSettingsQuery = { __typename?: 'Query', me?: { __typename?: 'MeQuery', user?: { __typename?: 'User', userId: string, userSettings: { __typename?: 'UserSettings', userId: string, testVal: number } } | null } | null };

export type GqlupdateMeUserSettingsMutationVariables = Exact<{
  userSettings: GqlUserSettingsUpdateInput;
}>;


export type GqlupdateMeUserSettingsMutation = { __typename?: 'Mutation', me?: { __typename?: 'MeMutation', updateUserSettings?: { __typename?: 'UserSettings', userId: string, testVal: number } | null } | null };

export const MeUserFragmentDoc = gql`
    fragment MeUser on User {
  userId
  firstName
  lastName
  userRoles
}
    `;
export const MeUserSettingsFragmentDoc = gql`
    fragment MeUserSettings on UserSettings {
  userId
  testVal
}
    `;
export const getMeUserDocument = gql`
    query getMeUser {
  me {
    user {
      ...MeUser
    }
  }
}
    ${MeUserFragmentDoc}`;

/**
 * __usegetMeUserQuery__
 *
 * To run a query within a Vue component, call `usegetMeUserQuery` and pass it any options that fit your needs.
 * When your component renders, `usegetMeUserQuery` returns an object from Apollo Client that contains result, loading and error properties
 * you can use to render your UI.
 *
 * @param options that will be passed into the query, supported options are listed on: https://v4.apollo.vuejs.org/guide-composable/query.html#options;
 *
 * @example
 * const { result, loading, error } = usegetMeUserQuery();
 */
export function usegetMeUserQuery(options: VueApolloComposable.UseQueryOptions<GqlgetMeUserQuery, GqlgetMeUserQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GqlgetMeUserQuery, GqlgetMeUserQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GqlgetMeUserQuery, GqlgetMeUserQueryVariables>> = {}) {
  return VueApolloComposable.useQuery<GqlgetMeUserQuery, GqlgetMeUserQueryVariables>(getMeUserDocument, {}, options);
}
export function usegetMeUserLazyQuery(options: VueApolloComposable.UseQueryOptions<GqlgetMeUserQuery, GqlgetMeUserQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GqlgetMeUserQuery, GqlgetMeUserQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GqlgetMeUserQuery, GqlgetMeUserQueryVariables>> = {}) {
  return VueApolloComposable.useLazyQuery<GqlgetMeUserQuery, GqlgetMeUserQueryVariables>(getMeUserDocument, {}, options);
}
export type getMeUserQueryCompositionFunctionResult = VueApolloComposable.UseQueryReturn<GqlgetMeUserQuery, GqlgetMeUserQueryVariables>;
export const getMeUserSettingsDocument = gql`
    query getMeUserSettings {
  me {
    user {
      userId
      userSettings {
        ...MeUserSettings
      }
    }
  }
}
    ${MeUserSettingsFragmentDoc}`;

/**
 * __usegetMeUserSettingsQuery__
 *
 * To run a query within a Vue component, call `usegetMeUserSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `usegetMeUserSettingsQuery` returns an object from Apollo Client that contains result, loading and error properties
 * you can use to render your UI.
 *
 * @param options that will be passed into the query, supported options are listed on: https://v4.apollo.vuejs.org/guide-composable/query.html#options;
 *
 * @example
 * const { result, loading, error } = usegetMeUserSettingsQuery();
 */
export function usegetMeUserSettingsQuery(options: VueApolloComposable.UseQueryOptions<GqlgetMeUserSettingsQuery, GqlgetMeUserSettingsQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GqlgetMeUserSettingsQuery, GqlgetMeUserSettingsQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GqlgetMeUserSettingsQuery, GqlgetMeUserSettingsQueryVariables>> = {}) {
  return VueApolloComposable.useQuery<GqlgetMeUserSettingsQuery, GqlgetMeUserSettingsQueryVariables>(getMeUserSettingsDocument, {}, options);
}
export function usegetMeUserSettingsLazyQuery(options: VueApolloComposable.UseQueryOptions<GqlgetMeUserSettingsQuery, GqlgetMeUserSettingsQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GqlgetMeUserSettingsQuery, GqlgetMeUserSettingsQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GqlgetMeUserSettingsQuery, GqlgetMeUserSettingsQueryVariables>> = {}) {
  return VueApolloComposable.useLazyQuery<GqlgetMeUserSettingsQuery, GqlgetMeUserSettingsQueryVariables>(getMeUserSettingsDocument, {}, options);
}
export type getMeUserSettingsQueryCompositionFunctionResult = VueApolloComposable.UseQueryReturn<GqlgetMeUserSettingsQuery, GqlgetMeUserSettingsQueryVariables>;
export const updateMeUserSettingsDocument = gql`
    mutation updateMeUserSettings($userSettings: UserSettingsUpdateInput!) {
  me {
    updateUserSettings(userSettings: $userSettings) {
      ...MeUserSettings
    }
  }
}
    ${MeUserSettingsFragmentDoc}`;

/**
 * __useupdateMeUserSettingsMutation__
 *
 * To run a mutation, you first call `useupdateMeUserSettingsMutation` within a Vue component and pass it any options that fit your needs.
 * When your component renders, `useupdateMeUserSettingsMutation` returns an object that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - Several other properties: https://v4.apollo.vuejs.org/api/use-mutation.html#return
 *
 * @param options that will be passed into the mutation, supported options are listed on: https://v4.apollo.vuejs.org/guide-composable/mutation.html#options;
 *
 * @example
 * const { mutate, loading, error, onDone } = useupdateMeUserSettingsMutation({
 *   variables: {
 *     userSettings: // value for 'userSettings'
 *   },
 * });
 */
export function useupdateMeUserSettingsMutation(options: VueApolloComposable.UseMutationOptions<GqlupdateMeUserSettingsMutation, GqlupdateMeUserSettingsMutationVariables> | ReactiveFunction<VueApolloComposable.UseMutationOptions<GqlupdateMeUserSettingsMutation, GqlupdateMeUserSettingsMutationVariables>> = {}) {
  return VueApolloComposable.useMutation<GqlupdateMeUserSettingsMutation, GqlupdateMeUserSettingsMutationVariables>(updateMeUserSettingsDocument, options);
}
export type updateMeUserSettingsMutationCompositionFunctionResult = VueApolloComposable.UseMutationReturn<GqlupdateMeUserSettingsMutation, GqlupdateMeUserSettingsMutationVariables>;
export const namedOperations = {
  Query: {
    getMeUser: 'getMeUser',
    getMeUserSettings: 'getMeUserSettings'
  },
  Mutation: {
    updateMeUserSettings: 'updateMeUserSettings'
  },
  Fragment: {
    MeUser: 'MeUser',
    MeUserSettings: 'MeUserSettings'
  }
}
export type AdminMutationKeySpecifier = ('hello' | AdminMutationKeySpecifier)[];
export type AdminMutationFieldPolicy = {
	hello?: FieldPolicy<any> | FieldReadFunction<any>
};
export type AdminQueryKeySpecifier = ('hello' | AdminQueryKeySpecifier)[];
export type AdminQueryFieldPolicy = {
	hello?: FieldPolicy<any> | FieldReadFunction<any>
};
export type ConnectionKeySpecifier = ('edges' | 'pageInfo' | ConnectionKeySpecifier)[];
export type ConnectionFieldPolicy = {
	edges?: FieldPolicy<any> | FieldReadFunction<any>,
	pageInfo?: FieldPolicy<any> | FieldReadFunction<any>
};
export type EdgeKeySpecifier = ('cursor' | EdgeKeySpecifier)[];
export type EdgeFieldPolicy = {
	cursor?: FieldPolicy<any> | FieldReadFunction<any>
};
export type MeMutationKeySpecifier = ('hello' | 'updateUserSettings' | MeMutationKeySpecifier)[];
export type MeMutationFieldPolicy = {
	hello?: FieldPolicy<any> | FieldReadFunction<any>,
	updateUserSettings?: FieldPolicy<any> | FieldReadFunction<any>
};
export type MeQueryKeySpecifier = ('hello' | 'user' | MeQueryKeySpecifier)[];
export type MeQueryFieldPolicy = {
	hello?: FieldPolicy<any> | FieldReadFunction<any>,
	user?: FieldPolicy<any> | FieldReadFunction<any>
};
export type MutationKeySpecifier = ('admin' | 'hello' | 'me' | MutationKeySpecifier)[];
export type MutationFieldPolicy = {
	admin?: FieldPolicy<any> | FieldReadFunction<any>,
	hello?: FieldPolicy<any> | FieldReadFunction<any>,
	me?: FieldPolicy<any> | FieldReadFunction<any>
};
export type PageInfoKeySpecifier = ('endCursor' | 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'totalCount' | PageInfoKeySpecifier)[];
export type PageInfoFieldPolicy = {
	endCursor?: FieldPolicy<any> | FieldReadFunction<any>,
	hasNextPage?: FieldPolicy<any> | FieldReadFunction<any>,
	hasPreviousPage?: FieldPolicy<any> | FieldReadFunction<any>,
	startCursor?: FieldPolicy<any> | FieldReadFunction<any>,
	totalCount?: FieldPolicy<any> | FieldReadFunction<any>
};
export type QueryKeySpecifier = ('admin' | 'hello' | 'me' | QueryKeySpecifier)[];
export type QueryFieldPolicy = {
	admin?: FieldPolicy<any> | FieldReadFunction<any>,
	hello?: FieldPolicy<any> | FieldReadFunction<any>,
	me?: FieldPolicy<any> | FieldReadFunction<any>
};
export type UserKeySpecifier = ('email' | 'firstName' | 'lastName' | 'userId' | 'userRoles' | 'userSettings' | UserKeySpecifier)[];
export type UserFieldPolicy = {
	email?: FieldPolicy<any> | FieldReadFunction<any>,
	firstName?: FieldPolicy<any> | FieldReadFunction<any>,
	lastName?: FieldPolicy<any> | FieldReadFunction<any>,
	userId?: FieldPolicy<any> | FieldReadFunction<any>,
	userRoles?: FieldPolicy<any> | FieldReadFunction<any>,
	userSettings?: FieldPolicy<any> | FieldReadFunction<any>
};
export type UserSettingsKeySpecifier = ('testVal' | 'userId' | UserSettingsKeySpecifier)[];
export type UserSettingsFieldPolicy = {
	testVal?: FieldPolicy<any> | FieldReadFunction<any>,
	userId?: FieldPolicy<any> | FieldReadFunction<any>
};
export type StrictTypedTypePolicies = {
	AdminMutation?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | AdminMutationKeySpecifier | (() => undefined | AdminMutationKeySpecifier),
		fields?: AdminMutationFieldPolicy,
	},
	AdminQuery?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | AdminQueryKeySpecifier | (() => undefined | AdminQueryKeySpecifier),
		fields?: AdminQueryFieldPolicy,
	},
	Connection?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | ConnectionKeySpecifier | (() => undefined | ConnectionKeySpecifier),
		fields?: ConnectionFieldPolicy,
	},
	Edge?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | EdgeKeySpecifier | (() => undefined | EdgeKeySpecifier),
		fields?: EdgeFieldPolicy,
	},
	MeMutation?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | MeMutationKeySpecifier | (() => undefined | MeMutationKeySpecifier),
		fields?: MeMutationFieldPolicy,
	},
	MeQuery?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | MeQueryKeySpecifier | (() => undefined | MeQueryKeySpecifier),
		fields?: MeQueryFieldPolicy,
	},
	Mutation?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | MutationKeySpecifier | (() => undefined | MutationKeySpecifier),
		fields?: MutationFieldPolicy,
	},
	PageInfo?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | PageInfoKeySpecifier | (() => undefined | PageInfoKeySpecifier),
		fields?: PageInfoFieldPolicy,
	},
	Query?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | QueryKeySpecifier | (() => undefined | QueryKeySpecifier),
		fields?: QueryFieldPolicy,
	},
	User?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | UserKeySpecifier | (() => undefined | UserKeySpecifier),
		fields?: UserFieldPolicy,
	},
	UserSettings?: Omit<TypePolicy, "fields" | "keyFields"> & {
		keyFields?: false | UserSettingsKeySpecifier | (() => undefined | UserSettingsKeySpecifier),
		fields?: UserSettingsFieldPolicy,
	}
};
export type TypedTypePolicies = StrictTypedTypePolicies & TypePolicies;
// Generated on 2023-06-15T22:37:12+02:00
